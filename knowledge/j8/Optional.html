<html>
<body>
    <h1>Тип Optional&lt;T&gt;</h1>
    <div>
        Объект типа Optional&lt;T&gt; может содержать внутри значение типа T или null.
    </div>
    <h2>Создание объектов типа Optional&lt;T&gt;</h2>
    <div>
        <ul>
            <li>Создание из значения, которое не может быть null:
                <code>Optional&lt;T&gt; optionalValue = Optional.of(value)</code>Eсли value == null, throws NullPointerException
            </li>
            <li>Создание пустого контейнера:
                <code>Optional&lt;T&gt; optionalValue = Optional.empty()</code>
            </li>
            <li>Создание из nullable значения:
                <code>Optional&lt;T&gt; optionalValue = Optional.ofNullable(value)</code>Если value == null, возвращает Optional.empty() 
            </li>
        </ul>
    </div>
    <h2>Примеры использования</h2>
    <div>
        <ul>
            <li>Если в контейнере не null, то значение распакуется, иначе, result инициализируется значением defaultValue:
                <code>T result = optionalValue.orElse(defaultValue)</code>
            </li>
            <li>Можно использовать лямбду (supplier) для инициализации значения при null внутри optionalValue:
                <code>T result = optionalValue.orElseGet(supplier)</code>
            </li>
            <li>Можно использовать ссылку на конструктор исключения для случая, если внутри optionalValue окажется null:
                <code>T result = optionalValue.orElseThrow(exceptionSupplier)</code>
            </li>
            <li>Значение может быть передано в consumer, если оно существует:
                <code>optionalValue.ifPresent(consumer)</code>
            </li>
            <li>Заворачивание результата, возвращаемого функцией function при обработке optionalValue, если оно не null.
                <code>Optional&lt;T&gt; newOptional = optionalValue.map(function);</code>Если внутри optionalValue - null, то newOptional также будет пустым.
            </li>
            <li>Композиция функций:
                <code>Optional&lt;T&gt; newOptional = value.f().flatMap(T::g)</code> 
                Eсли f() возвращает объект, 
                обёрнутый в Optional&lt;T&gt;, 
                то flatMap позволяет извлечь объект из обертки, 
                применить его метод g() 
                и поместить результат в обертку.
            </li>
        </ul>
    </div> 
</body>
</html>