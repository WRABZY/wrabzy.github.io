<!DOCTYPE html>
<html>
	<body>
    	<h1>Спец. версии коллекций</h1>
    	<p>
            <h2>WeakHashMap</h2>
            В WeakHashMap используются слабые ссылки для хранения ключей.
            В случаях, если на объект ссылаются только слабые ссылки, система сборки мусора удаляет объект.
    	</p>
        <p>
            <h2>LinkedHashSet</h2>
            <h2>LinkedHashMap</h2>
            Запоминают порядок ввода в них элементов путем составления связного списка из элементов при их введении.
            LinkedHashMap позволяет сменить порядок ввода на порядок доступа для перебора элементов.
            При каждом вызове get() или put() затрагиваемый элемент удаляется из его текущей позиции в 
            дополнительном связном списке и вводится в его конце. Эта особенность предназначена для
            реализации кеширования с наиболее давним использованием. Для автоматизации удаления наиболее
            старых элементов нужно образовать подкласс класса LinkedHashMap и переопредлить метод
            <code>protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code>
    	</p>
        <p>
            <h2>EnumSet</h2>
            <h2>EnumMap</h2>
            <div>
                Класс EnumSet эффективно реализует множество элементов, относящихся к перечислимому типу.
                EnumSet организован в виде битовой последовательности. Если значение перечисления присутствует в множестве, 
                то в соответствующем бите устанавливается 1. Для конструирования перечислимого множества испольуются статик фабрики.
            </div>
            <div>
                Класс EnumMap реализует отображение с ключами, относящимися к перечислимому типу.
                EnumMap представлено в виде массива значений. И создается следующим образом:
                <code>EnumMap&lt;Weekday, Employee&gt; personInCharge = new EnumMap&lt;&gt;(Weekday.class);</code>
            </div>
    	</p>
        <p>
            <h2>IdentityHashMap</h2>
            IdentityHashMap предназначен для работы с объектами, хеш-коды которых должны вычисляться методом
            System.identityHashCode(), в котором используется метод Object.hashCode(), то есть хеш-код
            вычисляется по адресу объекта в памяти. Кроме того, для сравнения объектов используется ==, а не equals().
            Таким образом, разные объекты-ключи рассматриваются как различные, даже при одинаковом содержимом.
    	</p>
	</body>
</html>