<!DOCTYPE html>
<html>
	<body>
    	<h1>Отображения</h1>
    	<p>
            В отображениях хранятся пары "ключ-значение".
    	</p>
        <p>
            <h2>Основные операции</h2>
            В библиотеке коллекций Java предоставлены две реализации отображений:
            HashMap и TreeMap (implements Map).
            Функции хеширования и сравнения применяются только к ключам.
            Хеширование выполняется немного быстрее, поэтому если не требуется
            отсортированный порядок, лучше применять HashMap.
        </p>
        <p>
            Если в отображении отсутствуют данные по указанному ключу, то get() возвращает null.
            Для получения вместо null значения по умолчанию, можно использовать:
            <code>map.getOrDefault(id, "default value");</code>
        </p>
        <p>
            Метод put() размещает в отображении элемент по ключу. Если элемент с данным ключом отсутствовал в отображении,
            put() вернет null, в противном случае put() вернет старое значение, которое хранилось по этому ключу, а внутри
            отображения заменит значение новым.
        </p>
        <p>
            Для перебора всех пар "ключ-значение" в отображении используется:
            <code>map.forEach((k, v) -> System.out.println("key = " + k + " value = " + v));</code>
        </p>
        <p>
            <h2>Изменение объектов внутри Map</h2>
            Например, подсчет определенных слов в тексте:
            <div>
                Инкремент счетчика с учетом случая, когда слово еще не встречалось:
                <code>map.put(word, map.getOrDefault(word, 0) + 1)</code>
            </div>
            <div>
                Использование putIfAbsent(k, v) - вводит значение только если ключ ранее отсутствовал:
                <code>map.putIfAbsent(word, 0)</code>
                <code>map.put(word, map.get(word) + 1)</code>
            </div>
            <div>
                Использование merge(k, v, \) - вводит значение, если ключ отсутствовал, в противном случае вводит значение с применением лямбды:
                <code>map.merge(word, 1, Integer::sum)</code>
            </div>
        </p>
        <p>
            <h2>Коллекции внутри Map</h2>
            Внутри Map "спрятаны" три коллекции:
            <ol>
                <li>Множество ключей
                    <code>Set&lt;K&gt; set = map.keySet();</code>
                </li>
                <li>Коллекция значений (возможны дубликаты)
                    <code>Collection&lt;V&gt; coll = map.values();</code>
                </li>
                <li>Множество пар "ключ-значение"
                    <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; set = map.entrySet();</code>
                </li>
            </ol>
            При этом keySet не является ни HashSet, ни TreeSet.
            <div>
                Метод remove() итератора множества ключей в итоге удаляет элемент по ключу из отображения.
                Ввод элементов с помощью итератора множества ключей невозможен.
            </div>
        </p>
	</body>
</html>