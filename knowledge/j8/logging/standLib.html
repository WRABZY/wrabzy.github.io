<html>
<body>
    <h1>java.util.logging.*</h1>
    <p>
        <h2>Ключевые элементы логирования</h2>
        <ul>
            <li>
                Объект класса Logger - логер, основная сущность в логировании.
            </li>
            <li>
                Объект класса LogRecord представляет сообщение (запись) лога. 
                Такие объекты можно передавать между фреймворком логирования и отдельными обработчиками (Handlers).
            </li>
            <li>
                Объект класса Handler - хендлер, выгружает объекты класса LogRecord
                в такие места как память, потоки вывода, терминалы, файлы, сокеты или другие хендлеры.
            </li>
            <li>
                Класс Level определяет набор стандартных уровней логирования, 
                которые могут использоваться для контроля вывода логов.
                Логирование может быть настроено таким образом, 
                чтобы логи одних уровней записывались, а других - игнорировались.
            </li>
            <li>
                Класс Filter предоставляет возможность тщательной фильтрации информации, которая записывается в лог.
            </li>
            <li>
                Класс Formater представляет средства для форматирования объектов LogRecord как обычного текста или в формате XML.
            </li>
        </ul>
        Логеры составляют иерархию по своему пространству имен,
        в которой дочерние объекты могут наследовать некоторые свойства родительских объектов.
    </p>
    <p>
        <h2>Поток логирования</h2>
        <div>
            Запись в лог осуществляется вызовом метода логера. 
            Методы логеров создают объекты LogRecord и отправляют их хендлерам на публикацию. 
            И логер, и хендлер могут иметь свои уровни логирования и фильтры.
            Хендлер может использовать форматтер для задания нужного форматирования перед записью лога.
            По умолчанию, без дополнительной настройки, все логеры среди прочего отсылают записи родительским хендлерам.
        </div>
        <mark>
            Вызовы команд логирования в программе при отключенном логировании не влияют на эффективность.
            Если логирование отключено только для некоторых уровней, то для каждой команды проводятся проверки на соответствие уровня логирования разрешенному.
            Локализация и форматирование выполняются в последнюю очередь, когда необходимость регистрации записи известна наверняка.
        </mark>
    </p>
    <p>
        <h2>Уровни логеров и хендлеров</h2>
        <div>
            Уровни логирования призваны разделять логи по важности. 
            Объект Level содержит int-значение, по которому его приоритет может сравниваться с другими уровнями.
        </div>
        <div>
            Существуют следующие уровни (в порядке уменьшения приоритета):
            <ol>
                <li>
                    SEVERE - используется по умолчанию
                </li>
                <li>
                    WARNING - используется по умолчанию
                </li>
                <li>
                    INFO - используется по умолчанию
                </li>
                <li>
                    CONFIG - необходимо задавать отдельно
                </li>
                <li>
                    FINE - необходимо задавать отдельно
                </li>
                <li>
                    FINER - необходимо задавать отдельно
                </li>
                <li>
                    FINEST - необходимо задавать отдельно
                </li>
            </ol>
            Задать уровень можно вызовом 
            <code>logger.setLevel(Level.FINE);</code>
            <mark>Сообщения регистрируются с заданного уровня и выше.</mark>
        </div>
    </p>
    <p>
        <h2>Логеры</h2>
        <div>
            Логеры именуются в стиле именования пакетов (с разделением точками). 
            Иерархическая структура пространства имен, при этом, управляется объектами LogManager.
        </div>
        <mark>
            Логеры могут не иметь имени (быть анонимными) и, соответственно, не принадлежать пространству имен.
        </mark>
        <div>
            Логеры отслеживают свои родительские логеры по пространству имен.
            Корневой логер носит имя "" и не имеет родителей. В конечном итоге все логеры, в том числе анонимные, 
            являются дочерними по отношению к корневому.
            Логеры могут наследовать от своих родительских логеров: уровень логирования, хендлеры, имена пакетов ресурсов.
            Чтобы произошло наследование того или иного свойства, оно задается для логера как null. 
            Кроме хендлеров, которые наследуются по умолчанию.
        </div>
    </p>
    <p>
        <h2>Методы логеров</h2>
        <div>
            Уровень логирования может передаваться методу как аргумент или отражаться названием метода:
            <code>logger.log(Level.WARNING, ...)</code>
            <code>logger.warning(...)</code>
        </div>
        <div>
            Методы логирования могут быть более или менее подробными в отношении предоставляемой логеру информации:
            <code>void warning(String sourceClass, String sourceMethod, String msg)</code>
            <code>void warning(String msg)</code>
            Хотя в случае использования краткой формы метода логирования фреймворк логирования попытается дополнить LogRecord
            названиями класса и метода, в которых произошел вызов метода, но эта информация может быть неточной из-за
            оптимизации, осуществляемой виртуальной машиной.
        </div>
    </p>
    <p>
        <h2>Хендлеры</h2>
        Стандартная библиотека предоставляет следующие хендлеры:
        <ul>
            <li>Простой хендлер для вывода отформатированных записей лога в поток вывода
                <code>StreamHandler</code>
            </li>
            <li>Простой хендлер для вывода отформатированных записей лога в System.err (используется по умолчанию)
                <code>ConsoleHandler</code>
            </li>
            <li>Хендлер для вывода отформатированных записей лога в файлы
                <code>FileHandler</code>
            </li>
            <li>Хендлер для вывода отформатированных записей лога на удаленные TCP порты
                <code>SocketHandler</code>
            </li>
            <li>Хендлер, буферизующий записи в памяти
                <code>MemoryHandler</code>
            </li>
        </ul>
    </p>
    <p>
        <h2>Форматеры</h2>
        Стандартных форматеров два:
        <ul>
            <li>Для читабельного форматирования логов:
                <code>SimpleFormatter</code>
            </li>
            <li>Для представления логов в формате XML:
                <code>XMLFormatter</code>
            </li>
        </ul>
    </p>
    <p>
        <h2>Менеджер логов</h2>
        <div>
            Существует глобальный объект - менеджер логов, который отслеживает:
            <ul>
                <li>
                    Иерархическое пространство имен неанонимных логеров
                </li>
                <li>
                    Набор свойств логирования, считываемых из конфигурационного файла
                </li>
            </ul>
            Для получения объекта менеджера существует статический метод:
            <code>LogManager.getLogManager()</code>
        </div>
    </p>
    <p>
        <h2>Файл конфигурации (конфиг)</h2>
        <div>
            Конфигурация логирования может быть прочитана из файла при запуске.
        </div>
        <mark>
            По умолчанию конфиг находится по адресу: jre/lib/logging.properties
        </mark>
        <div>
            Для изменения конфига при запуске программы нужно задать:
            <code>java -Djava.util.logging.config.file=новый_конфиг MainClass</code>
            Можно изменить используемый файл конфига вызовом двух методов:
            <code>System.setProperty("java.util.logging.config.file", file);</code>
            <code>LogManager.readConfiguration();</code>
            Второй вызов требуется для того, чтобы LogManager повторно инициализировался, 
            так как он инициализируется во время запуска виртуальной машины.
        </div>
    </p>
</body>
</html>