<html>
<body>
    <h1>Обобщения</h1>
    <p>
        <mark>
            Предупреждения компилятора, связанные с обобщениями, подавляются аннотацией @SuppressWarnings("unchecked").
        </mark>
    </p>
    <p>
        <h2>Соглашение о типовых переменных</h2>
        <ul>
            <li>E - элемент коллекции</li>
            <li>K - ключ (в отображении)</li>
            <li>V - значение (в отображении)</li>
            <li>S - любой тип</li>
            <li>T - любой тип, используется чаще всего</li>
            <li>U - любой тип</li>
        </ul>
    </p>
    <p>
        <h2>Обобщенные методы</h2>
        <div>
            <h3>Объявление обобщенных методов</h3>
            Обобщенные методы могут быть объявлены в любом классе.
            <code>public static &lt;T&gt; T callMethod(T... values)</code>
            &lt;T&gt; - переменная типа, вводится после модификатора доступа 
            перед указанием возвращаемого типа (в данном случае T)
        </div>
        <div>
            <h3>Вызов обобщенных методов</h3>
            Вызывать обощенные методы можно с указанием типа в угловых скобках
            <code>String result = ClassOrObject.&lt;String&gt;callMethod("a", "b", "c");</code>
            <code>String result = this.&lt;String&gt;callMethod("a", "b", "c");</code>
            Но часто параметр типа можно опустить:
            <code>String result = ClassOrObject.callMethod("a", "b", "c");</code>
            <code>String result = callMethod("a", "b", "c");</code>
            При передаче обобщенному методу параметров фактически разных классов
            компилятор попытыется вывести тип переданных параметров как их общий супертип.
            Если общих супертипов 2 или более - произойдет ошибка компиляции.
        </div>
    </p>
    <p>
        <h2>Ограничения на переменные типа</h2>
        <code>public static &lt;T extends SomeType&gt; T callMethod(T[] a)</code>
        SomeType - может быть как интерфейсом, так и классом.
        На переменную типа может накладываться несколько ограничений:
        <code>public static &lt;T extends Type & OtherType&gt; T callMethod(T[] a)</code>
        Только один из ограничивающих типов может быть классом.
        Если в список ограничений входит класс, он должен быть указан первым в списке ограничений.
    </p>
    <p>
        <h2>Обобщения внутри виртуальной машины</h2>
        <div>
            При создании обобщенного типа автоматически создается соответствующий ему базовый тип.
            Имя базового типа совпадает с именем обобщенного типа с удаленными параметрами типа.
            Переменные типа стираются и заменяются первым ограничивающим типом (или типом Object).
            К остальным ограничивающим типам там, где это потребуется, осуществляется приведение.
            <mark>Ради эффективности маркирующие интерфейсы (без методов) следует размещать в конце списка ограничений.</mark>
        </div>
        <div>
            Вызов метода, возвращающего значение типа, заданного типовой переменной, преобразуется в две команды для ВМ:
            <ul>
                <li>Вызов метода базового типа</li>
                <li>Приведение типа результата (первого ограничивающего типа или типа Object)
                к типу, который должен был вернуться при вызове метода.</li>
            </ul>
            Приведение типа также требуется при прямом обращении к обобщенным полям обобщенного класса.
        </div>
        <div>
            <h3>Мостовые методы</h3>
            Рассмотрим пример:
            <code>class AnyClass&lt;T&gt; {</code>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; void someMethod(T arg) { ... }</code>
            <code>}</code>
            При наследовании от AnyClass&lt;T&gt; и при переопределении метода someMethod():
            <code>class OtherClass extends AnyClass&lt;String&gt; {</code>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;public void someMethod(String arg) { ... }</code>
            <code>}</code>
            В классе OtherClass фактически будет определено два метода:
            <code>public void someMethod(Object arg) { ... }</code>
            <code>public void someMethod(String arg) { ... }</code>
            Так как AnyClass после компиляции будет определен как 
            <code>class AnyClass {</code>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;public void someMethod(Object arg) { ... }</code>
            <code>}</code>
            Для обеспечения принципа полиморфизма метод someMethod(Object arg) в классе наследнике 
            автоматически генерируется как мостовой, в нем происходит вызов требуемого метода:
            <code>public void someMethod(Object arg) {</code>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;someMethod((OtherClass) arg);</code>
            <code>}</code>
            Более того мостовые методы могут различаться только возвращаемым типом, 
            хотя вручную объявить методы с одинаковой сигнатурой, отличающиеся только типами результатов, нельзя. 
        </div>
        <mark>Обобщений для ВМ не существует. Параметры типа заменяются ограничивающими типами.
        Мостовые методы синтезируются для соблюдения принципов полиморфизма. Для обеспечения типовой безопасности вводятся операции приведения типов.</mark>
    </p>
    <p>
        <h2>Ограничения обобщений</h2>
        <div>
            <mark>
                Обобщенные типы не могут использоваться в операциях, в которых явно зайдействованы
                типы времени выполнения: приведения типов, операции instanceof и выражения new.
            </mark>
        </div>
        <div>
            <h3>Запрос обобщенного типа возвращает базовый тип</h3>
            Нельзя проверить "a instanceof Pair&lt;String&gt;" (ошибка компиляции), но можно "a instanceof Pair"
            При вызове stringPair.getClass():
            <code>Pair&lt;String&gt; stringPair = ...</code>
            <code>stringPair.getClass()</code>
            вернется объект типа Pair.class
        </div>
        <div>
            <h3>В угловые скобки нельзя подставлять примитивы</h3>
            Так как примитивные типы не имеют ограничения (и не наследуются от Object).
        </div>
        <div>
            <h3>Массивы параметризованных типов недопустимы</h3>
            Из-за стирания типом массива во время выполнения может быть только Object[].
            <mark>
                Если требуется массив объектов обобщенного типа, то лучше воспользоваться ArrayList: ArrayList&lt;Pair&lt;String&gt;&gt;
            </mark>
        </div>
        <div>
            <h3>Параметры типа могут использоваться для обозначения переменного числа аргументов</h3>
            При этом метод неплохо помечать аннотацией @SafeVarargs.
        </div>
        <div>
            <h3>Переменные типа в статическом контексте обобщенных классов недействительны</h3>
            Так как после стирания типов остается один класс, статические поля и методы также существуют в одном экземпляре.
        </div>
        <div>
            <h3>Обощенный класс не может расширять класс Throwable</h3>
            Кроме того, переменную типа нельзя использовать в блоке catch.
        </div>
    </p>
    <p>
        <h2>Подстановочные типы</h2>
        <h3>? extends SomeType</h3>
        <div>
            От Pair наследует Pair&lt;? extends Employee&gt;
        </div>
        <div>
            От Pair&lt;? extends Employee&gt; наследуют Pair&lt;Manager&gt; и Pair&lt;Employee&gt;
        </div>
        <div>
            При использовании подстановки Pair&lt;? extends Employee&gt; в классе имеются методы:
            <code>? extends Employee getFirst()</code>
            <code>void setFirst(? extends Employee)</code>
            <div>
                getFirst() возвращает объект какого-то класса, производного от Employee, то есть результат можно присвоить ссылке типа Employee.
            </div>
            <div>
                setFirst() принимает объект какого-то класса, производного от Employee, и должен его присвоить ссылке какого-то класса,
                производного от Employee. Такая неопределенность делает невозможным вызов сеттера.
            </div>
            <mark>
                Главный смысл подстановок заключается в разделении безопасных методов доступа и небезопасных модифицирующих методов.
            </mark>
        </div>
        <h3>? super OtherType</h3>
        <div>
            Такая подстановка ограничивается всеми супертипами OtherType и дает поведение, противоположное ? extends.
        </div>
        <div>
            От Pair наследует Pair&lt;?&gt;
        </div>
        <div>
            От Pair&lt;?&gt; наследует Pair&lt;? super Manager&gt;
        </div>
        <div>
            От Pair&lt;? super Manager&gt; наследуют Pair&lt;Object&gt; и Pair&lt;Employee&gt;
        </div>
        <div>
            При использовании подстановки Pair&lt;? super Manager&gt; в классе имеются методы:
            <code>? super Manager getFirst()</code>
            <code>void setFirst(? super Manager)</code>
            <div>
                getFirst() возвращает объект какого-то класса, от которого наследует Manager.
                Из-за неопределенности результат можно присвоить только ссылке типа Object.
            </div>
            <div>
                setFirst() принимает объект для того, чтобы присвоить ссылку на него переменной типа Manager или предкам Manager.
                Поэтому setFirst() не может принимать предков Manager, но может принять Manager или объекты производных классов относительно Manager.
            </div>
        </div>
        <mark>
            Подстановки super - для записи в обобщенный объект, extends - для чтения из обобщенного объекта.
        </mark>
    </p>
</body>
</html>