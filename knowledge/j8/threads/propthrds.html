<!DOCTYPE html>
<html>
    <body>
        <h1>Свойства</h1>
        <p>
            <h2>Приоритеты потоков</h2>
            <div>
                По умолчанию поток наследует приоритет от породившего его потока.
                Задать приоритет потока можно методом
                <code>void setPriority(int newPriority)</code>
                Приоритет задается в диапазоне от MIN_PRIORITY (int 1) до MAX_PRIORITY (int 10).
                По умолчанию используется NORM_PRIORITY (int 5).
            </div>
            <div>
                При выборе потока для исполнения планировщик выбирает потоки с более высоким приоритетом.
                Приоритеты потоков зависят от системы. Например в Windows 10 уровней приоритетов 
                потоков Java отображаются на 7 приоритетов потоков Windows. 
                В ВМ Oracle для Linux все потоки имеют одинаковый приоритет.
                Возможны ситуации, когда потоки с более высокими приоритетами занимают все время выполнения,
                не давая выполняться потокам с приоритетами ниже.
                <code>Thread.yield()</code>
                Заставляет текущий исполняемый поток уступить управление.
            </div>
        </p>
        <p>
            <h2>Потоковые демоны</h2>
            <div>
                Для превращения потока в демона используется вызов:
                <code>t.setDaemon(true);</code>
            </div>
            <div>
                Когда остаются только потоковые демоны, виртуальная машина завершает работу.
                Потоковые демоны не должны обращаться к постоянным ресурсам.
            </div>
        </p>
        <p>
            <h2>Исключения в методе run()</h2>
            <div>
                Метод run() не может генерировать никаких проверяемых исключений,
                но может быть прерван непроверяемым исключением.
                В этом случае поток исполнения уничтожается. При этом нельзя создать конструкцию 
                catch, куда может распространиться непроверяемое исключение.
            </div>
            <div>
                Вместо этого перед уничтожением потока исключение передается обработчику необрабатываемых исключений.
                Он должен относиться к классу, реализующему интерфейс Thread.UncaughtExceptionHandler с единственным
                методом:
                <code>void uncaughtException(Thread t, Throwable e)</code>
                Такой обработчик можно установить в любом потоке исполнения вызовом:
                <code>t.setUncaughtExceptionHandler()</code>
                Кроме того можно установить дефолтный обработчик для всех потоков:
                <code>Thread.setDefaultUncaughtExceptionHandler()</code>
                Неустановленный дефолтный обработчик является null,
                но неустановленный обработчик конкретного потока означает, что в его качестве используется
                объект ThreadGroup (не рекомендуется использовать ThreadGroup для работы с коллекцией потоков).
                <code>class ThreadGroup implements Thread.UncaughtExceptionHandler</code>
                Его метод uncaughtException() выполняет следующие действия:
                <ol>
                    <li>
                        Если у группы потоков имеется родительская группа, то из нее вызывается метод uncaughtException().
                    </li>
                    <li>
                        Иначе, если дефолтный обработчик не null, то он и вызывается.
                    </li>
                    <li>
                        Иначе, если объект Throwable является инстансом ThreadDeath, то ничего не происходит.
                    </li>
                    <li>
                        Иначе, имя потока и трассировка стека выводятся в стандартный System.err.
                    </li>
                </ol>
            </div>
        </p>
    </body>
</html>