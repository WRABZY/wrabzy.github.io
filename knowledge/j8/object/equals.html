<!DOCTYPE html>
<html>
	<body>
    	<h1>equals()</h1>
        <code>boolean equals(Object obj)</code>
    	<div>
            Не переопределенный метод equals() проверяет, ссылаются ли переменные на один и тот же объект.
    	</div>
        <div>
            Требования спецификации Java к методу equals():
            <ol>
                <li>
                    Рефлексивность:
                    <code>x.equals(x) == true</code>
                </li>
                <li>
                    Симметричность:
                    <code>x.equals(y) == true &lt;=&gt; y.equals(x) == true</code>
                </li>
                <li>
                    Транзитивность:
                    <code>if x.equals(y) == true && y.equals(z) == true</code>
                    <code>then x.equals(z) == true</code>
                </li>
                <li>
                    Согласованность:
                    <code>if x.equals(y) == true && объекты не были изменены,</code>
                    <code>то повторно x.equals(y) == true</code>
                </li>
            </ol>
        </div>
        <div>
            Рецепт equals() от К. Хорстманна:
            <ol>
                <li>
                    Присвойте явному параметру имя otherObject. Впоследствии его тип 
                    нужно будет привести к типу другой переменной под названием other.
                </li>
                <li>
                    Проверьте, одинаковы ли ссылки this и otherObject, следующим образом:
                    <code>if (this == otherObject) return true;</code>
                </li>
                <li>
                    Выясните, является ли ссылка otherObject пустой (null), как показано ниже.
                    Если она оказывается пустой, следует вернуть false. Эту проверку нужно сделать обязательно.
                    <code>if (otherObject == null) return false;</code>
                </li>
                <li>
                    Сравните классы this и otherObject. Если семантика проверки может измениться в подклассе,
                    воспользуйтесь методом getClass() следующим образом:
                    <code>if (getClass() != otherObject.getClass()) return false;</code>
                    Если одна и та же семантика остается справедливой для всех подклассов, произведите проверку
                    с помощью операции instanceof:
                    <code>if (!(otherObject instanceof ClassName)) return false;</code>
                </li>
                <li>
                    Приведите тип объекта otherObject к типу переменной требуемого класса:
                    <code>ClassName other = (ClassName) otherObject;</code>
                </li>
                <li>
                    Сравните все поля, как показано ниже. Для полей примитивных типов служит операция ==,
                    а для объектных полей методы Objects.equals() / Arrays.equals():
                    <code>return f1 == other.f1 && f2.equals(other.f2) && Objects.equals(f3, other.f3)</code>
                </li>
                <li>
                    При переопределении equals() в подклассе включите в него вызов super.equals(other).
                </li>
            </ol>
        </div>
	</body>
</html>