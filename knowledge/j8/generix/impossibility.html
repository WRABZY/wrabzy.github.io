<html>
<body>
    <h1>Невозможности обобщений</h1>
    <div>
        <mark>
            Обобщенные типы не могут использоваться в операциях, в которых явно зайдействованы
            типы времени выполнения: приведения типов, операции instanceof и выражения new.
        </mark>
    </div>
    <p>
        <h3>Запрос обобщенного типа возвращает базовый тип</h3>
        <div>
            Нельзя проверить "a instanceof Pair&lt;String&gt;" (ошибка компиляции), но можно "a instanceof Pair"
            При вызове stringPair.getClass():
            <code>Pair&lt;String&gt; stringPair = ...</code>
            <code>stringPair.getClass()</code>
            вернется объект типа Pair.class
        </div>
        <h3>В угловые скобки нельзя подставлять примитивы</h3>
        <div>
            Так как примитивные типы не имеют ограничения (и не наследуются от Object).
        </div>
        <h3>Массивы параметризованных типов недопустимы</h3>
        <div>
            Из-за стирания типом массива во время выполнения может быть только Object[].
            Если требуется массив объектов обобщенного типа, то лучше воспользоваться ArrayList: 
            <code>
                ArrayList&lt;Pair&lt;String&gt;&gt
            </code>
            Но параметры типа могут использоваться для обозначения переменного числа аргументов.
        </div>
        <h3>Переменные типа в static контексте обобщенных классов недействительны</h3>
        <div>
            Так как после стирания типов остается один класс, статические поля и методы также существуют в одном экземпляре.
        </div>
        <h3>Обощенный класс не может расширять класс Throwable</h3>
        <div>
            Каждое catch выражение в try-catch проверяет тип полученного исключения во время выполнения программы 
            (что равносильно instanceof). Поэтому Throwable и его подтипы не могут быть параметризованы.
        </div>
    </p>
</body>
</html>