<html>
<body>
    <h1>Потоки данных (Stream API)</h1>
    <div>
         <ol>
            <li>
                Поток данных не сохраняет свои элементы.
                Они либо хранятся в коллекции, либо формируются по требованию.
            </li>
            <li>
                Потоковые операции не изменяют источник данных.
            </li>
            <li>
                Цепочка потоковых операций выполняется только при вызове терминальной операции.
                Потоки могут быть бесконечными.
            </li>
        </ol>
    </div>
    <div>
        Конвейер операций состоит в следующем:
        <ol>
            <li>
                Создание потока данных.
            </li>
            <li>
                Промежуточные операции для преобразования исходного потока
                данных.
            </li>
            <li>
                Выполнение конечной операции - принуждает к выполнению
                операции преобразования.
            </li>
        </ol>
        После вызова конечной операции поток закрывается, его больше нельзя использовать.
    </div> 
    <h2>Способы создания потоков данных</h2>
    <div>
        <ul>
            <li>
                Поток без элементов:
                <code>Stream.empty();</code>
            </li>
            <li>
                Из отдельных данных:
                <code>Stream.of(data1, data2, data3);</code>
            </li>
            <li>
                Из массива: 
                <code>Stream.of(array);</code>
            </li>
            <li>
                Из части массива: 
                <code>Arrays.stream(array, startInc, endExc);</code>
            </li>
            <li>
                Из коллекции:
                <code>collection.stream(); <mark>parallelStream</mark></code>
            </li>
            <li>
                Бесконечный поток:
                <code>Stream.generate(supplier);</code>
            </li>
            <li>
                Бесконечная последовательность:
                <code>Stream.iterate(firstValue, unaryOperator);</code>
            </li>
            <li>
                Из строки:
                <code>Pattern.compile("regex").splitAsStream(charSequence);</code>
            </li>
            <li>
                Из файла:
                <code>Files.lines(path); <mark>lines(path, charset)</mark></code>
            </li>
            <li>
                Луч:
                <code>IntStream.range(0, 100);</code>
            </li>
            <li>
                Отрезок:
                <code>IntStream.rangeClosed(0, 100);</code>
            </li>
        </ul>
        Список не является исчерпывающим.
    </div> 
    <h2>Способы преобразования потоков данных</h2>
    <div>
        Эти операции не выполняются до вызова терминальной операции.
        <ul>
            <li>
                <code>stream.filter(predicate);</code> - фильтрация
            </li>
            <li>
                <code>stream.map(function);</code>
                - преобразование каждого элемента функцией (возвращающей значение)
            </li>
            <li>
                <code>stream.flatMap(function);</code>
                - если function возвращает потоки, то flatMap конкатенирует их в один поток
            </li>
            <li>
                <code>stream.limit(maxSize);</code>
                - ограничение максимального количества элементов
            </li>
            <li>
                <code>stream.skip(n);</code>
                - отбрасывание первых n элементов
            </li>
            <li>
                <code>Stream.concat(stream1, stream2);</code>
                - конкатенация двух потоков
            </li>
            <li>
                <code>stream.distinct();</code>
                - удаление дубликатов из потока
            </li>
            <li>
                <code>stream.sorted(); <mark>sorted(comparator)</mark></code>
                - сортировка потока
            </li>
            <li>
                <code>stream.peek(consumer);</code>
                - передаваемая функция вызывается при извлечении каждого элемента
            </li>
        </ul>
        Список не является исчерпывающим.
    </div> 
    <h2>Терминальные операции с потоками</h2>
    <div>
        <ul>
            <li>
                <code>long stream.count();</code> - подсчет элементов в потоке
            </li>
            <li>
                <code>Optional&lt;T&gt; stream.min(comparator); <mark>max</mark></code> 
                - получение минимального или максимального значения в потоке
            </li>
            <li>
                <code>Optional&lt;T&gt; stream.findFirst();</code> 
                - получение первого значения в потоке
            </li>
            <li>
                <code>Optional&lt;T&gt; stream.findAny();</code> 
                - получение любого значения в потоке
            </li>
            <li>
                <code>boolean stream.anyMatch(predicate); <mark>allMatch, noneMatch</mark></code> 
                - проверка, имеются ли совпадения
            </li>
            <li>
                <code>void stream.forEach(consumer); <mark>forEachOrdered</mark></code> 
                - применение функции к каждому значению в потоке
            </li>
            <li>
                <code>Object[] stream.toArray(); [toArray(intFunction)]</code> 
                - преобразование потока в массив <mark>String[] toArray(String[]::new)</mark>
            </li>
            <li>
                <code>Collection&lt;T&gt; stream.collect(collector);</code> 
                - преобразование потока в коллекцию <mark>класс Collectors предоставляет фабрики коллекторов</mark>
            </li>
            <li>
                <code>Optional&lt;T&gt; stream.reduce(binaryOperator);</code> 
                - свертка с использованием первого элемента потока как первого значения <mark>T reduce(identity, binaryOperator) - для использования отдельного первого значения. Если поток пуст, то вернется значение identity. Есть третья форма метода reduce для использования с аккумулятором.</mark>
            </li>
        </ul>
    </div>
</body>
</html>